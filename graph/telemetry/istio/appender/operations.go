package appender

import (
	"fmt"
	"math"
	"time"

	"github.com/prometheus/common/model"

	"github.com/kiali/kiali/graph"
	"github.com/kiali/kiali/graph/telemetry/istio/util"
	"github.com/kiali/kiali/log"
	"github.com/kiali/kiali/prometheus"
)

const (
	// OperationsAppenderName uniquely identifies the appender: operations
	OperationAppenderName = "operations"
)

// OperationsAppender is responsible for adding "op" nodes into the graph.
// Name: operations
type OperationsAppender struct {
	GraphType          string
	InjectServiceNodes bool
	Namespaces         graph.NamespaceInfoMap
}

// Name implements Appender
func (a OperationsAppender) Name() string {
	return OperationsAppenderName
}

// AppendGraph implements Appender
func (a OperationsAppender) AppendGraph(trafficMap graph.TrafficMap, globalInfo *graph.AppenderGlobalInfo, namespaceInfo *graph.AppenderNamespaceInfo) {
	if len(trafficMap) == 0 {
		return
	}

	if globalInfo.PromClient == nil {
		var err error
		globalInfo.PromClient, err = prometheus.NewClient()
		graph.CheckError(err)
	}

	a.appendGraph(trafficMap, namespaceInfo.Namespace, globalInfo.PromClient)
}

func (a OperationsAppender) appendGraph(trafficMap graph.TrafficMap, namespace string, client *prometheus.Client) {
	// We query for destination telemetry (generated by the destination proxy) because request classification is
	// performed only for requests that reach the destination workload.

	// create map destNodeId->to quickly look up Operations
	OperationsMap := make(map[string]float64)

	// query prometheus for the Operations info in three queries:
	// note - Istio is migrating their latency metric from seconds to milliseconds. We need to support both until
	//        the 'seconds' variant is removed. That is why we have these complex queries with OR logic.
	// 1) query for Operations originating from "unknown" (i.e. the internet)
	groupBy := fmt.Sprintf("le,source_workload_namespace,source_workload,source_%s,source_%s,destination_service_namespace,destination_service,destination_service_name,destination_workload_namespace,destination_workload,destination_%s,destination_%s,response_code,grpc_response_status", appLabel, verLabel, appLabel, verLabel)
	millisQuery := fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="destination",source_workload="unknown",destination_workload_namespace="%v"}[%vs])) by (%s))`,
		quantile,
		"istio_request_duration_milliseconds_bucket",
		namespace,
		int(duration.Seconds()), // range duration for the query
		groupBy)
	secondsQuery := fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="destination",source_workload="unknown",destination_workload_namespace="%v"}[%vs])) by (%s))`,
		quantile,
		"istio_request_duration_seconds_bucket",
		namespace,
		int(duration.Seconds()), // range duration for the query
		groupBy)
	query := fmt.Sprintf(`((%s > 0) OR ((%s > 0) * 1000.0))`, millisQuery, secondsQuery)
	unkVector := promQuery(query, time.Unix(a.QueryTime, 0), client.API(), a)
	a.populateOperationsMap(OperationsMap, &unkVector)

	// 2) query for external traffic, originating from a workload outside of the namespace.  Exclude any "unknown" source telemetry (an unusual corner case)
	reporter := "source"
	sourceWorkloadQuery := fmt.Sprintf(`source_workload_namespace!="%s"`, namespace)
	/*
		if isIstio {
			// also exclude any non-requested istio namespaces
			reporter = "destination"
			excludedIstioNamespaces := config.GetIstioNamespaces(a.Namespaces.GetIstioNamespaces())
			if len(excludedIstioNamespaces) > 0 {
				excludedIstioRegex := strings.Join(excludedIstioNamespaces, "|")
				sourceWorkloadQuery = fmt.Sprintf(`source_workload_namespace!~"%s|%s"`, namespace, excludedIstioRegex)
			}
		}
	*/
	millisQuery = fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="%s",%s,source_workload!="unknown",destination_service_namespace="%v"}[%vs])) by (%s))`,
		quantile,
		"istio_request_duration_milliseconds_bucket",
		reporter,
		sourceWorkloadQuery,
		namespace,
		int(duration.Seconds()), // range duration for the query
		groupBy)
	secondsQuery = fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="%s",%s,source_workload!="unknown",destination_service_namespace="%v"}[%vs])) by (%s))`,
		quantile,
		"istio_request_duration_seconds_bucket",
		reporter,
		sourceWorkloadQuery,
		namespace,
		int(duration.Seconds()), // range duration for the query
		groupBy)
	query = fmt.Sprintf(`((%s > 0) OR ((%s > 0) * 1000.0))`, millisQuery, secondsQuery)
	outVector := promQuery(query, time.Unix(a.QueryTime, 0), client.API(), a)
	a.populateOperationsMap(OperationsMap, &outVector)

	// 3) query for Operations originating from a workload inside of the namespace
	millisQuery = fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="source",source_workload_namespace="%v"}[%vs])) by (%s))`,
		quantile,
		"istio_request_duration_milliseconds_bucket",
		namespace,
		int(duration.Seconds()), // range duration for the query
		groupBy)
	secondsQuery = fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="source",source_workload_namespace="%v"}[%vs])) by (%s))`,
		quantile,
		"istio_request_duration_seconds_bucket",
		namespace,
		int(duration.Seconds()), // range duration for the query
		groupBy)
	query = fmt.Sprintf(`((%s > 0) OR ((%s > 0) * 1000.0))`, millisQuery, secondsQuery)
	inVector := promQuery(query, time.Unix(a.QueryTime, 0), client.API(), a)
	a.populateOperationsMap(OperationsMap, &inVector)

	// Query3 misses istio-to-istio traffic, which is only reported destination-side, we must perform an additional query
	/*
		if isIstio {
			// find traffic from the source istio namespace to any of the requested istio namespaces
			istioNamespacesRegex := strings.Join(getIstioNamespaces(a.Namespaces), "|")

			// 3a) supplemental query for istio-to-istio traffic
			millisQuery = fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="destination",source_workload_namespace="%s",destination_service_namespace=~"%s"}[%vs])) by (%s))`,
				quantile,
				"istio_request_duration_milliseconds_bucket",
				namespace,
				istioNamespacesRegex,
				int(duration.Seconds()), // range duration for the query
				groupBy)
			secondsQuery = fmt.Sprintf(`histogram_quantile(%.2f, sum(rate(%s{reporter="destination",source_workload_namespace="%s",destination_service_namespace=~"%s"}[%vs])) by (%s))`,
				quantile,
				"istio_request_duration_seconds_bucket",
				namespace,
				istioNamespacesRegex,
				int(duration.Seconds()), // range duration for the query
				groupBy)
			query = fmt.Sprintf(`((%s > 0) OR ((%s > 0) * 1000.0))`, millisQuery, secondsQuery)
			// fetch the internally originating request traffic time-series
			inIstioVector := promQuery(query, time.Unix(a.QueryTime, 0), client.API(), a)
			a.populateOperationsMap(OperationsMap, &inIstioVector)
		}
	*/

	applyOperations(trafficMap, OperationsMap)
}

func applyOperations(trafficMap graph.TrafficMap, OperationsMap map[string]float64) {
	for _, n := range trafficMap {
		for _, e := range n.Edges {
			key := fmt.Sprintf("%s %s", e.Source.ID, e.Dest.ID)
			if val, ok := OperationsMap[key]; ok {
				e.Metadata[graph.Operations] = val
			}
		}
	}
}

func (a OperationsAppender) populateOperationsMap(OperationsMap map[string]float64, vector *model.Vector) {
	for _, s := range *vector {
		m := s.Metric
		lSourceWlNs, sourceWlNsOk := m["source_workload_namespace"]
		lSourceWl, sourceWlOk := m["source_workload"]
		lSourceApp, sourceAppOk := m[model.LabelName("source_"+appLabel)]
		lSourceVer, sourceVerOk := m[model.LabelName("source_"+verLabel)]
		lDestSvcNs, destSvcNsOk := m["destination_service_namespace"]
		lDestSvc, destSvcOk := m["destination_service"]
		lDestSvcName, destSvcNameOk := m["destination_service_name"]
		lDestWlNs, destWlNsOk := m["destination_workload_namespace"]
		lDestWl, destWlOk := m["destination_workload"]
		lDestApp, destAppOk := m[model.LabelName("destination_"+appLabel)]
		lDestVer, destVerOk := m[model.LabelName("destination_"+verLabel)]
		lResponseCode, responseCodeOk := m["response_code"]
		lGrpcResponseStatus, grpcReponseStatusOk := m["grpc_response_status"]

		if !sourceWlNsOk || !sourceWlOk || !sourceAppOk || !sourceVerOk || !destSvcNsOk || !destSvcNameOk || !destSvcOk || !destWlNsOk || !destWlOk || !destAppOk || !destVerOk || !responseCodeOk {
			log.Warningf("Skipping %v, missing expected labels", m.String())
			continue
		}

		sourceWlNs := string(lSourceWlNs)
		sourceWl := string(lSourceWl)
		sourceApp := string(lSourceApp)
		sourceVer := string(lSourceVer)
		destSvcNs := string(lDestSvcNs)
		destSvc := string(lDestSvc)
		destSvcName := string(lDestSvcName)
		destWlNs := string(lDestWlNs)
		destWl := string(lDestWl)
		destApp := string(lDestApp)
		destVer := string(lDestVer)
		responseCode := string(lResponseCode)

		if util.IsBadSourceTelemetry(sourceWlNs, sourceWl, sourceApp) {
			continue
		}

		// This was added in istio 1.5, handle in a backward compatible way
		grpcReponseStatus := "0"
		if grpcReponseStatusOk {
			grpcReponseStatus = string(lGrpcResponseStatus)
		}

		// Only valid requests contribute to response time so as not to skew RT when a failed request returns immediately
		// TODO: Note, we can do this filtering in the queries when and if all supported Istio versions provide grpc_response_status
		if grpcReponseStatus != "0" || regexpHTTPFailure.MatchString(responseCode) {
			continue
		}

		val := float64(s.Value)
		destSvcNs, destSvcName = util.HandleMultiClusterRequest(sourceWlNs, sourceWl, destSvcNs, destSvcName)

		if util.IsBadDestTelemetry(destSvc, destSvcName, destWl) {
			continue
		}

		// It is possible to get a NaN if there is no traffic (or possibly other reasons). Just skip it
		if math.IsNaN(val) {
			continue
		}

		// don't inject a service node if destSvcName is not set or the dest node is already a service node.
		inject := false
		if a.InjectServiceNodes && graph.IsOK(destSvcName) {
			_, destNodeType := graph.Id(destSvcNs, destSvcName, destWlNs, destWl, destApp, destVer, a.GraphType)
			inject = (graph.NodeTypeService != destNodeType)
		}
		if inject {
			// Do not set response time on the incoming edge, we can't validly aggregate response times of the outgoing edges (kiali-2297)
			a.addOperations(OperationsMap, val, destSvcNs, destSvcName, "", "", "", destSvcNs, destSvcName, destWlNs, destWl, destApp, destVer)
		} else {
			a.addOperations(OperationsMap, val, sourceWlNs, "", sourceWl, sourceApp, sourceVer, destSvcNs, destSvcName, destWlNs, destWl, destApp, destVer)
		}
	}
}

func (a OperationsAppender) addOperations(OperationsMap map[string]float64, val float64, sourceNs, sourceSvc, sourceWl, sourceApp, sourceVer, destSvcNs, destSvc, destWlNs, destWl, destApp, destVer string) {
	sourceID, _ := graph.Id(sourceNs, sourceSvc, sourceNs, sourceWl, sourceApp, sourceVer, a.GraphType)
	destID, _ := graph.Id(destSvcNs, destSvc, destWlNs, destWl, destApp, destVer, a.GraphType)
	key := fmt.Sprintf("%s %s", sourceID, destID)

	OperationsMap[key] = val
}
